{
  # amend = "commit --amend --all --no-edit";
  author = ''!f() { CONTENT=$(test -n "$1" && git log --author="$1" --pretty="%aN <%aE>" -1); echo "''${CONTENT:-$(git config user.name) <$(git config user.email)>}"; }; f'';
  authors = ''shortlog --summary --numbered --email --all'';
  backup = ''!git push --force-with-lease "$(git remote)" $(git branch --show-current):user/$(git config --get user.handle)/trunk'';
  restore = ''!git pull "$(git remote)" user/$(git config --get user.handle)/trunk:$(git branch --show-current)'';
  # c = "commit -am";
  # cat-deleted = ''!f() { git cat-file -p "$(git log --pretty=%H --diff-filter=AM -1 -- "$1"):$1"; }; f'';
  # co = "checkout";
  # count = ''!git rev-list --left-right --count HEAD...$1 | sed 's/\t/↑↓/';'';
  # d = ''!"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat --color-words"'';
  # diffr  = ''!f() { git diff "$1"^.."$1"; }; f'';
  # diffunc = "diff --cached";
  # discard = "checkout --";
  # dl = ''!git ll -1'';
  # dlc = "diff --cached HEAD^";
  # dr  = ''!f() { git diff "$1"^.."$1"; }; f'';
  # f = ''!git ls-files | grep -i'';
  # fadd = ''!git ls-files -m -o --exclude-standard | fzf --print0 -0 -m --preview 'git diff --color=always {}' --preview-window=down:10:wrap | xargs -0 -t -o git add --all'';
  # fblame = ''!git ls-files | fzf -m --preview 'git blame --color-lines {}' | ifne xargs -n1 git blame'';
  # fco = ''!git branch -a | awk '$1 == "*" {system("tput setaf 3");print $2;system("tput sgr0");next};{print $1}' | fzf --ansi | sed 's|^remotes/|--track |' | xargs -t git checkout'';
  # fdel = ''!git branch -a | awk '$1 == "*" {system("tput setaf 3");print $2;system("tput sgr0");next};{print $1}' | fzf --ansi -m | awk '$0 ~ /^remotes/ {print "push origin --delete",$0;next}{print "branch -D",$0}' | sed 's|remotes/origin/||g' | ifne xargs -L 1 git'';
  # fdiff = ''!f() { git diff --name-only --color=always $@ | fzf -m --ansi --preview \"git diff $@ --color=always -- {-1}\" | ifne xargs git diff $@ --; }; f'';
  # fed = ''!FILES=`git status -s | awk '{ print $2 }' | fzf -x -m` && code ''${FILES}'';
  # fedconflicts = ''!FILES=`git status -s | grep '^[UMDA]\{2\} ' | awk '{ print $2 }' | fzf -x -m` && ''${EDITOR} ''${FILES}'';
  # fedlog = ''!HASH=`git log --pretty=oneline | head -n 50 | fzf` && HASHZ=`echo ''${HASH} | awk '{ print $1 }'` && FILES=`git show --pretty='format:' --name-only $HASHZ | grep -v -e '^$' | fzf -x -m` && code ''${FILES}'';
  # ffix = ''!HASH=`git log --pretty=oneline | head -n 100 | fzf` && git fixit `echo ''${HASH} | awk '{ print $1 }'`'';
  # fgrep = ''!sh -c 'FILES=`git grep -l -A 0 -B 0 $1 $2 | fzf -x -m` && code `echo ''${FILES} | cut -d':' -f1 | xargs`' -'';
  # filelog = "log -u";
  # find-deleted = ''!git log --diff-filter=D --summary | grep delete | cut -d' ' -f5- | sort -h'';
  # fix = "!git diff --name-only --diff-filter=U | ifne xargs $EDITOR";
  # fixall = ''!f() { COUNT=$(git rev-list --left-right --count $(git branch --show-current)...$(git rev-parse --abbrev-ref --symbolic-full-name @{u}) | xargs | cut -d' ' -f1); git rebase --autosquash HEAD~$COUNT; }; f'';
  # fixit = ''!f() { git commit --fixup=$1; GIT_SEQUENCE_EDITOR=: git rebase -i --autosquash $1~1; }; f'';
  # fixup = ''!sh -c 'REV=$(git rev-parse $1) && git commit --fixup $@ && git rebase -i --autosquash $REV^' -'';
  # fl = "log -u";
  # frebase = ''!HASH=`git log --pretty=oneline | head -n 100 | fzf` && git rebase -i `echo ''${HASH} | awk '{ print $1 }'`^'';
  # freset = ''!HASH=`git log --pretty=oneline | head -n 50 | fzf` && git reset --soft `echo ''${HASH} | awk '{ print $1 }'`^'';
  git = "!exec git"; # Needed for piping
  # gr = "grep -Ii";
  # gra = ''!f() { A=$(pwd) && TOPLEVEL=$(git rev-parse --show-toplevel) && cd $TOPLEVEL && git grep --full-name -In $1 | xargs -I{} echo $TOPLEVEL/{} && cd $A; }; f'';
  # graph = ''log --graph -10 --branches --remotes --tags  --format=format:'%Cgreen%h %Creset• %<(75,trunc)%s (%cN, %cr) %Cred%d' --date-order'';
  # grep = "grep -Ii";
  head = "log --pretty=oneline --show-signature HEAD^..HEAD";
  # last-deleted = ''!f() { git log --pretty=%H -''${1:-1} --diff-filter=D | xargs -n1 git diff-tree --no-commit-id --name-only --diff-filter=D -r | sort -u; }; f'';
  lasttag = "describe --tags --abbrev=0";
  # lc  = ''!f() { git ll "$1"^.."$1"; }; f'';
  # lds = ''log --pretty=format:"%C(yellow)%h\ %ad%Cred%d\ %Creset%s%Cblue\ [%cn]%Creset" --decorate --date=short'';
  # le = "log --oneline --decorate";
  # lg = ''log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --'';
  # ll = ''log --pretty=format:"%C(yellow)%h%Cred%d\ %Creset%s%Cblue\ [%cn]%Creset" --decorate --numstat'';
  # lnc = ''log --pretty=format:"%h\ %s\ [%cn]"'';
  # local-prune = ''!git fetch -p && for branch in $(git for-each-ref --format '%(refname) %(upstream:track)' refs/heads | awk '$2 == "[gone]" {sub("refs/heads/", "', $1); print $1}'); do git branch -D $branch; done'';
  ls = ''log --pretty=format:"%C(yellow)%h%Cred%d\ %Creset%s%Cblue\ [%cn]%Creset" --decorate'';
  # lt = "describe --tags --abbrev=0";
  # nevermind = ''!git reset --hard HEAD && git clean -d -f'';
  # notes-push = "push origin 'refs/notes/*'";
  # nuke = "reset --hard";
  # pick = "cherry-pick";
  please = "push --force-with-lease";
  # precommit = "diff --cached --diff-algorithm=minimal -w";
  # purge = ''!f() { git filter-branch --force --index-filter \"git rm --cached --ignore-unmatch "$1"\" --prune-empty --tag-name-filter cat -- --all; }; f'';
  # r = "rebase --autosquash";
  # ra = "rebase --abort";
  # rc = "rebase --continue";
  # resign = "rebase --exec 'git commit --amend --no-edit --no-verify --gpg-sign' --interactive";
  # reverse = "revert HEAD";
  # review = ''!f() { BRANCHES=$(git branch --no-column --all --format=\"%(refname:lstrip=2)\") && BASE=$(echo $BRANCHES | tr ' ' '\n' | fzf --prompt='Base branch: ') && TARGET=$(echo $BRANCHES | tr ' ' '\n' | fzf --prompt='Target branch: ') && echo \"git fdiff $BASE..$TARGET\" && git fdiff $BASE..$TARGET; }; f'';
  # ri = "rebase --autosquash -i";
  # rr = "rebase --autosquash --root";
  s = "status";
  # scrap = "reset --hard HEAD^";
  # seek-n-blame = ''!f() { git blame $(git log --pretty=%H --diff-filter=AM -1 -- "$1") -- "$1"; }; f'';
  # short-recent = ''for-each-ref --count=25 --sort=committerdate refs/heads/ --format="%(refname:short)"'';
  # subrm = ''!f(){ git submodule deinit -f $1; git rm -rf $1 || true; rm -rf .git/modules/$1; git config -f .git/config --remove-section submodule.$1; git config -f .gitmodules --remove-section submodule.$1 || true; }; f'';
  # tgrep = ''!f() { A=$(pwd) && TOPLEVEL=$(git rev-parse --show-toplevel) && cd $TOPLEVEL && FILES=`git ls-files | fzf -m` && git rev-list --all --since=$2 | xargs -I% git grep $1 % -- $FILES; cd $A; }; f'';
  # uncommit = "reset --mixed HEAD~";
  # unstage = "reset -q HEAD --";
  # unwind = "reset --soft HEAD^";
  # update-head = ''!git remote set-head "$(git remote)" --auto'';
  # who-deleted = ''!f() { git show -s --pretty=medium $(git log --pretty=%H -1 --diff-filter=D -- "$1"); }; f'';
  yolo = "push --force";
}
